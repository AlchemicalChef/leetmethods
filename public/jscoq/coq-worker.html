<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />
    <title>jsCoq Worker</title>
  </head>

<body class="jscoq-main">
  <div id="ide-wrapper" class="toggled">
    <div id="code-wrapper">
      <div id="document">
        <textarea class="coq-code">
Theorem and_commutative : forall A B : Prop, A /\ B -> B /\ A.
Proof.
  intros A B H.
  destruct H as [HA HB].
  split.
  - exact HB.
  - exact HA.
Qed.
</textarea>
      </div>
    </div>
  </div>

  <script type="module">
    import { JsCoq } from './jscoq.js';

    var jscoq_ids  = ['.coq-code'];
    var jscoq_opts = {
        prelude:       true,
        implicit_libs: true,
        editor:        { mode: { 'company-coq': false } },
        init_pkgs:     ['init'],
        all_pkgs:      ['coq']
    };

    let mgr = null;
    let ready = false;
    let goalObserverInstalled = false;

    JsCoq.start(jscoq_ids, jscoq_opts).then(manager => {
      mgr = manager;
      console.log('[coq-worker] JsCoq started');
      manager.when_ready.then(() => {
        ready = true;
        console.log('[coq-worker] Coq is ready!');
        installObserver();
        if (window.parent !== window) {
          window.parent.postMessage({ type: 'coq-ready' }, '*');
        }
      });
    }).catch(err => {
      console.error('[coq-worker] JsCoq failed:', err);
      if (window.parent !== window) {
        window.parent.postMessage({ type: 'coq-error', error: String(err) }, '*');
      }
    });

    function installObserver() {
      if (goalObserverInstalled || !mgr?.coq?.observers) return;
      goalObserverInstalled = true;

      mgr.coq.observers.push({
        coqGoalInfo(sid, goals) {
          if (window.parent !== window) {
            parent.postMessage({ type: 'coq-goals', goals: goals }, '*');
          }
        },
        coqError(sid, loc, msg) {
          if (window.parent !== window) {
            parent.postMessage({ type: 'coq-exec-error', sid, error: String(msg) }, '*');
          }
        },
        coqLog(level, msg) {
          if (level === 'Error' && window.parent !== window) {
            parent.postMessage({ type: 'coq-log-error', error: String(msg) }, '*');
          }
        }
      });
    }

    function waitForProcessing(timeoutMs) {
      timeoutMs = timeoutMs || 30000;
      return new Promise(function(resolve, reject) {
        var startTime = Date.now();
        function check() {
          var sentences = mgr && mgr.doc && mgr.doc.sentences;
          if (!sentences || sentences.length === 0) { resolve(); return; }
          var allDone = sentences.every(function(stm) {
            return stm.phase === 'processed' || stm.phase === 'error' || (stm.flags && stm.flags.is_comment);
          });
          if (allDone) { resolve(); return; }
          if (Date.now() - startTime > timeoutMs) { reject(new Error('timeout')); return; }
          setTimeout(check, 100);
        }
        setTimeout(check, 50);
      });
    }

    window.addEventListener('message', async function(event) {
      var data = event.data;
      if (!data || !data.cmd) return;

      var id = data.id;
      var cmd = data.cmd;
      var args = data.args || {};

      try {
        switch (cmd) {
          case 'ping':
            parent.postMessage({ type: 'coq-pong', id: id, ready: ready }, '*');
            break;

          case 'set-code': {
            if (!mgr || !mgr.provider || !mgr.provider.snippets || !mgr.provider.snippets[0] || !mgr.provider.snippets[0].editor) {
              parent.postMessage({ type: 'coq-result', id: id, error: 'not ready' }, '*');
              return;
            }
            mgr.provider.snippets[0].editor.setValue(args.code);
            parent.postMessage({ type: 'coq-result', id: id, ok: true }, '*');
            break;
          }

          case 'exec-next': {
            if (!mgr || !ready) {
              parent.postMessage({ type: 'coq-result', id: id, error: 'not ready' }, '*');
              return;
            }
            var result = mgr.goNext(false);
            if (result !== false) {
              await waitForProcessing(15000);
            }
            parent.postMessage({ type: 'coq-result', id: id, ok: true, hasMore: result !== false }, '*');
            break;
          }

          case 'exec-all': {
            if (!mgr || !ready) {
              parent.postMessage({ type: 'coq-result', id: id, error: 'not ready' }, '*');
              return;
            }
            var queued = 0;
            while (mgr.goNext(false) !== false) queued++;
            if (queued > 0) {
              await waitForProcessing(30000);
            }

            var sentences = (mgr.doc && mgr.doc.sentences) || [];
            var processedCount = sentences.filter(function(stm) {
              return stm.phase === 'processed' && !(stm.flags && stm.flags.is_comment);
            }).length;
            var errorStms = sentences.filter(function(stm) { return stm.phase === 'error'; });
            var errors = errorStms.map(function(stm) {
              var fb = stm.feedback && stm.feedback.find(function(f) { return f.level === 'Error'; });
              return (fb && fb.msg) || stm.text || 'error';
            });
            var mgrErrors = (mgr.error || []).map(function(stm) { return stm.text || 'Unknown'; });

            parent.postMessage({
              type: 'coq-result', id: id, ok: true,
              processedCount: Math.max(0, processedCount - 1),
              totalQueued: queued,
              errors: errors.concat(mgrErrors)
            }, '*');
            break;
          }

          case 'reset': {
            if (!mgr) {
              parent.postMessage({ type: 'coq-result', id: id, error: 'not ready' }, '*');
              return;
            }
            await mgr.reset();
            parent.postMessage({ type: 'coq-result', id: id, ok: true }, '*');
            break;
          }

          case 'exec-prev': {
            if (!mgr || !ready) {
              parent.postMessage({ type: 'coq-result', id: id, error: 'not ready' }, '*');
              return;
            }
            mgr.goPrev(false);
            await new Promise(function(resolve) { setTimeout(resolve, 200); });
            parent.postMessage({ type: 'coq-result', id: id, ok: true }, '*');
            break;
          }

          default:
            parent.postMessage({ type: 'coq-result', id: id, error: 'unknown cmd: ' + cmd }, '*');
        }
      } catch (err) {
        parent.postMessage({ type: 'coq-result', id: id, error: String(err) }, '*');
      }
    });
  </script>
</body>
</html>
