<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />
    <title>jsCoq Worker</title>
  </head>

<body class="jscoq-main">
  <div id="ide-wrapper" class="toggled">
    <div id="code-wrapper">
      <div id="document">
        <textarea class="coq-code">
Theorem and_commutative : forall A B : Prop, A /\ B -> B /\ A.
Proof.
  intros A B H.
  destruct H as [HA HB].
  split.
  - exact HB.
  - exact HA.
Qed.
</textarea>
      </div>
    </div>
  </div>

  <script type="module">
    import { JsCoq } from './jscoq/jscoq.js';

    var jscoq_ids  = ['.coq-code'];
    var jscoq_opts = {
        prelude:       true,
        implicit_libs: true,
        editor:        { mode: { 'company-coq': false } },
        init_pkgs:     ['init'],
        all_pkgs:      ['coq']
    };

    let mgr = null;
    let ready = false;

    /** Convert jsCoq Pp AST objects to plain text strings */
    function ppToString(pp) {
      // If mgr has a pretty-printer, use it
      if (mgr && mgr.pprint && typeof mgr.pprint.pp2Text === 'function') {
        try { return mgr.pprint.pp2Text(pp); } catch(e) { /* fallback below */ }
      }
      // Already a string
      if (typeof pp === 'string') return pp;
      // Recursively walk the Pp AST: ['Pp_glue', [...children]] / ['Pp_string', 'text'] / etc.
      if (Array.isArray(pp)) {
        var tag = pp[0];
        if (tag === 'Pp_string') return pp[1] || '';
        if (tag === 'Pp_glue' || tag === 'Pp_box') return (pp[1] || []).map(ppToString).join('');
        if (tag === 'Pp_tag')  return ppToString(pp[2]);
        if (tag === 'Pp_force_newline' || tag === 'Pp_print_break') return ' ';
        // Unknown tag — try to concatenate children
        return pp.slice(1).map(function(c) {
          return Array.isArray(c) ? (typeof c[0] === 'string' && c[0].startsWith('Pp_') ? ppToString(c) : c.map(ppToString).join('')) : String(c);
        }).join('');
      }
      return String(pp);
    }

    JsCoq.start(jscoq_ids, jscoq_opts).then(manager => {
      mgr = manager;
      console.log('[coq-worker] JsCoq started');
      manager.when_ready.then(() => {
        ready = true;
        console.log('[coq-worker] Coq is ready!');

        // Install goal/error observer
        if (mgr.coq && mgr.coq.observers) {
          mgr.coq.observers.push({
            coqGoalInfo(sid, goals) {
              if (window.parent !== window) {
                parent.postMessage({ type: 'coq-goals', goals: goals }, PARENT_ORIGIN);
              }
            },
            coqError(sid, loc, msg) {
              if (window.parent !== window) {
                parent.postMessage({ type: 'coq-exec-error', sid, error: ppToString(msg) }, PARENT_ORIGIN);
              }
            },
            coqLog(level, msg) {
              if (level === 'Error' && window.parent !== window) {
                parent.postMessage({ type: 'coq-log-error', error: ppToString(msg) }, PARENT_ORIGIN);
              }
            },
            feedAddedAxiom(sid) {
              if (window.parent !== window) {
                parent.postMessage({ type: 'coq-added-axiom', sid: sid }, PARENT_ORIGIN);
              }
            }
          });
        }

        // Register command handler AFTER Coq is fully ready
        window.addEventListener('message', handleCommand);

        // Notify parent
        if (window.parent !== window) {
          window.parent.postMessage({ type: 'coq-ready' }, PARENT_ORIGIN);
        }
      });
    }).catch(err => {
      console.error('[coq-worker] JsCoq failed:', err);
      if (window.parent !== window) {
        window.parent.postMessage({ type: 'coq-error', error: String(err) }, window.location.origin);
      }
    });

    function waitForProcessing(timeoutMs) {
      timeoutMs = timeoutMs || 30000;
      return new Promise(function(resolve, reject) {
        var startTime = Date.now();
        function check() {
          var sentences = mgr && mgr.doc && mgr.doc.sentences;
          if (!sentences || sentences.length === 0) { resolve(); return; }
          var allDone = sentences.every(function(stm) {
            return stm.phase === 'processed' || stm.phase === 'error' || (stm.flags && stm.flags.is_comment);
          });
          if (allDone) { resolve(); return; }
          if (Date.now() - startTime > timeoutMs) { reject(new Error('timeout')); return; }
          setTimeout(check, 100);
        }
        setTimeout(check, 50);
      });
    }

    var PARENT_ORIGIN = window.location.origin;

    async function handleCommand(event) {
      // Only accept commands from our parent, same origin
      if (event.source !== window.parent) return;
      if (event.origin !== PARENT_ORIGIN) return;
      var data = event.data;
      if (!data || !data.cmd) return;

      var id = data.id;
      var cmd = data.cmd;
      var args = data.args || {};

      try {
        switch (cmd) {
          case 'ping':
            parent.postMessage({ type: 'coq-pong', id: id, ready: ready }, PARENT_ORIGIN);
            break;

          case 'set-code': {
            if (!mgr || !mgr.provider || !mgr.provider.snippets || !mgr.provider.snippets[0] || !mgr.provider.snippets[0].editor) {
              parent.postMessage({ type: 'coq-result', id: id, error: 'not ready' }, PARENT_ORIGIN);
              return;
            }
            mgr.provider.snippets[0].editor.setValue(args.code);
            parent.postMessage({ type: 'coq-result', id: id, ok: true }, PARENT_ORIGIN);
            break;
          }

          case 'exec-next': {
            if (!mgr || !ready) {
              parent.postMessage({ type: 'coq-result', id: id, error: 'not ready' }, PARENT_ORIGIN);
              return;
            }
            var result = mgr.goNext(false);
            if (result !== false) {
              await waitForProcessing(15000);
            }
            parent.postMessage({ type: 'coq-result', id: id, ok: true, hasMore: result !== false }, PARENT_ORIGIN);
            break;
          }

          case 'exec-all': {
            if (!mgr || !ready) {
              parent.postMessage({ type: 'coq-result', id: id, error: 'not ready' }, PARENT_ORIGIN);
              return;
            }
            var queued = 0;
            while (mgr.goNext(false) !== false) queued++;
            if (queued > 0) {
              await waitForProcessing(30000);
            }

            var sentences = (mgr.doc && mgr.doc.sentences) || [];
            var processedCount = sentences.filter(function(stm) {
              return stm.phase === 'processed' && !(stm.flags && stm.flags.is_comment);
            }).length;
            var errorStms = sentences.filter(function(stm) { return stm.phase === 'error'; });
            var errors = errorStms.map(function(stm) {
              var fb = stm.feedback && stm.feedback.find(function(f) { return f.level === 'Error'; });
              return fb ? ppToString(fb.msg) : (stm.text || 'error');
            });
            var mgrErrors = (mgr.error || []).map(function(stm) { return stm.text || 'Unknown'; });

            parent.postMessage({
              type: 'coq-result', id: id, ok: true,
              processedCount: processedCount,
              totalQueued: queued,
              errors: errors.concat(mgrErrors)
            }, PARENT_ORIGIN);
            break;
          }

          case 'reset': {
            if (!mgr) {
              parent.postMessage({ type: 'coq-result', id: id, error: 'not ready' }, PARENT_ORIGIN);
              return;
            }
            // mgr.reset() restarts the worker and calls coqInit(), but the
            // promise resolves BEFORE the worker is actually ready.
            // coqReady() resets fresh_id — if we goNext() before it fires,
            // state IDs become non-monotonic → stm.ml assertion failure.
            // Fix: wait for coqReady to fire after reset.
            var resetReadyPromise = new Promise(function(resolve) {
              var origCoqReady = mgr.coqReady.bind(mgr);
              mgr.coqReady = function(sid) {
                origCoqReady(sid);
                mgr.coqReady = origCoqReady;
                resolve();
              };
            });
            await mgr.reset();
            await resetReadyPromise;
            parent.postMessage({ type: 'coq-result', id: id, ok: true }, PARENT_ORIGIN);
            break;
          }

          case 'exec-prev': {
            if (!mgr || !ready) {
              parent.postMessage({ type: 'coq-result', id: id, error: 'not ready' }, PARENT_ORIGIN);
              return;
            }
            mgr.goPrev(false);
            await waitForProcessing(15000);
            parent.postMessage({ type: 'coq-result', id: id, ok: true }, PARENT_ORIGIN);
            break;
          }

          default:
            parent.postMessage({ type: 'coq-result', id: id, error: 'unknown cmd: ' + cmd }, PARENT_ORIGIN);
        }
      } catch (err) {
        parent.postMessage({ type: 'coq-result', id: id, error: String(err) }, PARENT_ORIGIN);
      }
    }
  </script>
</body>
</html>
